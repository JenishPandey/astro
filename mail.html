<!DOCTYPE html>
<meta charset="utf-8">
<style>

.graticule {
  fill: none;
  stroke: #777;
}

.boundary {
  fill: rgb(0,128,32);
  fill-opacity: 1;
  stroke: #333;
  
}

.background {
	fill: rgb(0,64,255);
	fill-opacity: 0.8;
	
}
.point {
	fill: #800;
	
}

</style>
<body>
<script src="http://ajax.googleapis.com/ajax/libs/jquery/1.8.3/jquery.min.js"></script>
<script src="http://d3js.org/d3.v3.min.js"></script>
<script src="http://d3js.org/d3.geo.projection.v0.min.js"></script>
<script src="http://d3js.org/topojson.v0.min.js"></script>
<script src="https://raw.github.com/d3/d3-plugins/master/geo/tile/tile.js"></script>
<script>

var width = $(window).width(),
    height = $(window).height();
var origin = [640, 400];

var projection = d3.geo.orthographic();

projection
	.translate([width / 2, height / 2])
	.clipAngle(90 + 1e-6)
	.precision(0)
	.scale(300);

var latLonToPoint = function(lon,lat) {
	if(lat == undefined){
		var lat = lon[1];
		var lon = lon[0];
	}
	return projection()([lon,lat]);
};

var pointToLatLon = function(x,y) {
	if(y == undefined){
		var y = x[1];
		var x = x[0];
	}

	return projection().invert([x,y]);
};


var zoom = d3.behavior.zoom()
    .scale(projection.scale())
    .translate([width / 2, height / 2])
    .on("zoom", zoomed);

var graticule = d3.geo.graticule()
    .extent([[-180, -90], [180 + 1e-6, 90 + 1e-6]])
    .step([12,12]);

var path = d3.geo.path()
    .projection(projection);
  



var center = function(latlon) {
	if(offset == undefined) var offset=[0,0];
	projection.rotate([-latlon[0] -offset[0],-latlon[1] - offset[1],30]);
	refresh();

}

var svg = d3.select("body").append("svg")
    .attr("width", width)
    .attr("height", height)
    .call(zoom);

svg.append("path")
    .datum({type: "Sphere"})
    .attr("class", "background")
    .attr("d", path);

svg.append("path")
    .datum(graticule)
    .attr("class", "graticule")
    .attr("d", path);
    
$.getJSON("http://ollie.ws/geo/?file=world-50m&callback=?", function(world) {
  svg.append("path")
      .datum(world)
      .attr("class", "boundary")
      .attr("d", path);

});

var refresh = function(duration) {
var path = d3.geo.path()
    .projection(projection);
	if(duration == undefined || duration == 0 ){
		d3.selectAll("path.boundary").attr("d", path);
		d3.selectAll("path.graticule").attr("d", path);
		d3.selectAll("path.background").attr("d", path);
	}
	else {
		d3.selectAll("path.boundary").transition().duration(duration).attr("d", path);
		d3.selectAll("path.graticule").transition().duration(duration).attr("d", path);
		d3.selectAll("path.background").attr("d", path);
	}
};

function zoomed() {

  if(zoom.scale() != projection.scale()){
  	projection.scale(zoom.scale());
  }
  else {
	var rotation = projection.rotate();
	rotation[0] = 360*( zoom.translate()[0] - width/2)/width;
	rotation[1] = 180*( height/2 - zoom.translate()[1])/height;
	projection.rotate(rotation);
	
  }
  refresh();

}


d3.select(self.frameElement).style("height", height + "px");

</script>
